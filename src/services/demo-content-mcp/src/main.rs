//! Demo Content MCP Server with Gemini Flash Integration
//!
//! A working demonstration MCP server for the AI-CORE MVP demo using real Gemini API.

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Json},
    routing::{get, post},
    Router,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::env;
use tokio::net::TcpListener;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing::{error, info, warn};
use uuid::Uuid;

#[derive(Clone)]
pub struct AppState {
    pub service_name: String,
    pub gemini_client: GeminiClient,
}

#[derive(Clone)]
pub struct GeminiClient {
    pub api_key: String,
    pub client: reqwest::Client,
}

// Request/Response types
#[derive(Debug, Deserialize)]
pub struct ContentRequest {
    pub content_type: String,
    pub topic: String,
    pub target_audience: Option<String>,
    pub tone: Option<String>,
    pub include_images: Option<bool>,
    pub word_count: Option<usize>,
}

#[derive(Debug, Serialize)]
pub struct ContentResponse {
    pub id: Uuid,
    pub content_type: String,
    pub title: String,
    pub content: String,
    pub word_count: usize,
    pub status: String,
    pub created_at: DateTime<Utc>,
    pub processing_time_ms: u64,
    pub ai_model: String,
}

#[derive(Debug, Serialize)]
pub struct HealthStatus {
    pub status: String,
    pub service: String,
    pub timestamp: DateTime<Utc>,
    pub gemini_available: bool,
}

#[derive(Debug, Serialize)]
struct GeminiRequest {
    contents: Vec<GeminiContent>,
    generation_config: GeminiGenerationConfig,
}

#[derive(Debug, Serialize)]
struct GeminiContent {
    parts: Vec<GeminiPart>,
}

#[derive(Debug, Serialize)]
struct GeminiPart {
    text: String,
}

#[derive(Debug, Serialize)]
struct GeminiGenerationConfig {
    temperature: f32,
    top_k: u32,
    top_p: f32,
    max_output_tokens: u32,
}

#[derive(Debug, Deserialize)]
struct GeminiResponse {
    candidates: Vec<GeminiCandidate>,
}

#[derive(Debug, Deserialize)]
struct GeminiCandidate {
    content: GeminiResponseContent,
    #[serde(rename = "finishReason")]
    finish_reason: Option<String>,
}

#[derive(Debug, Deserialize)]
struct GeminiResponseContent {
    parts: Vec<GeminiResponsePart>,
}

#[derive(Debug, Deserialize)]
struct GeminiResponsePart {
    text: String,
}

impl GeminiClient {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let api_key = env::var("GEMINI_API_KEY")
            .map_err(|_| "GEMINI_API_KEY environment variable not set")?;

        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .build()?;

        Ok(Self { api_key, client })
    }

    pub async fn generate_content(
        &self,
        prompt: &str,
        max_tokens: u32,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let url = format!(
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={}",
            self.api_key
        );

        let request_body = GeminiRequest {
            contents: vec![GeminiContent {
                parts: vec![GeminiPart {
                    text: prompt.to_string(),
                }],
            }],
            generation_config: GeminiGenerationConfig {
                temperature: 0.7,
                top_k: 40,
                top_p: 0.95,
                max_output_tokens: max_tokens,
            },
        };

        let response = self
            .client
            .post(&url)
            .header("Content-Type", "application/json")
            .json(&request_body)
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("Gemini API error {}: {}", status, error_text).into());
        }

        let gemini_response: GeminiResponse = response.json().await?;

        if let Some(candidate) = gemini_response.candidates.first() {
            if let Some(part) = candidate.content.parts.first() {
                return Ok(part.text.clone());
            }
        }

        Err("No content generated by Gemini".into())
    }

    pub async fn test_connection(&self) -> bool {
        let test_prompt = "Test connection. Respond with just 'OK'.";
        match self.generate_content(test_prompt, 10).await {
            Ok(_) => true,
            Err(e) => {
                warn!("Gemini connection test failed: {}", e);
                false
            }
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter("demo_content_mcp=info,tower_http=debug")
        .init();

    info!(
        "Starting Demo Content MCP Server v{} with Gemini Flash",
        env!("CARGO_PKG_VERSION")
    );

    // Initialize Gemini client
    let gemini_client = match GeminiClient::new() {
        Ok(client) => {
            info!("Gemini client initialized successfully");
            // Test connection
            if client.test_connection().await {
                info!("Gemini API connection verified");
            } else {
                warn!("Gemini API connection test failed - service will use fallback content");
            }
            client
        }
        Err(e) => {
            error!("Failed to initialize Gemini client: {}", e);
            warn!("Service will run with fallback content generation");
            // Create a dummy client for fallback mode
            GeminiClient {
                api_key: "fallback".to_string(),
                client: reqwest::Client::new(),
            }
        }
    };

    let state = AppState {
        service_name: "demo-content-mcp".to_string(),
        gemini_client,
    };

    let app = create_router(state);

    let listener = TcpListener::bind("0.0.0.0:8804").await?;
    info!("Demo Content MCP Server listening on http://0.0.0.0:8804");

    axum::serve(listener, app).await?;
    Ok(())
}

fn create_router(state: AppState) -> Router {
    Router::new()
        .route("/health", get(health_check))
        .route("/v1/content/generate", post(generate_content))
        .route("/v1/content/:content_id", get(get_content))
        .route("/v1/capabilities", get(get_capabilities))
        .layer(TraceLayer::new_for_http())
        .layer(CorsLayer::permissive())
        .with_state(state)
}

async fn health_check(State(state): State<AppState>) -> impl IntoResponse {
    let gemini_available =
        state.gemini_client.api_key != "fallback" && env::var("GEMINI_API_KEY").is_ok();

    Json(HealthStatus {
        status: "healthy".to_string(),
        service: state.service_name,
        timestamp: Utc::now(),
        gemini_available,
    })
}

async fn generate_content(
    State(state): State<AppState>,
    Json(request): Json<ContentRequest>,
) -> Result<impl IntoResponse, StatusCode> {
    let start_time = std::time::Instant::now();

    info!(
        "Generating {} content for topic: {} using Gemini Flash",
        request.content_type, request.topic
    );

    let (title, content) = match generate_ai_content(&state.gemini_client, &request).await {
        Ok((t, c)) => {
            info!("Content generated successfully using Gemini API");
            (t, c)
        }
        Err(e) => {
            warn!("Gemini API failed ({}), using fallback content", e);
            generate_fallback_content(&request)
        }
    };

    let processing_time = start_time.elapsed().as_millis() as u64;
    let word_count = content.split_whitespace().count();

    let response = ContentResponse {
        id: Uuid::new_v4(),
        content_type: request.content_type,
        title,
        content,
        word_count,
        status: "completed".to_string(),
        created_at: Utc::now(),
        processing_time_ms: processing_time,
        ai_model: "gemini-1.5-flash".to_string(),
    };

    info!(
        "Content generated successfully: {} words in {}ms",
        response.word_count, processing_time
    );

    Ok(Json(response))
}

async fn generate_ai_content(
    gemini_client: &GeminiClient,
    request: &ContentRequest,
) -> Result<(String, String), Box<dyn std::error::Error>> {
    let target_words = request
        .word_count
        .unwrap_or(match request.content_type.as_str() {
            "blog_post" => 800,
            "social_media_post" => 100,
            "email_newsletter" => 500,
            _ => 400,
        });

    let audience = request
        .target_audience
        .as_deref()
        .unwrap_or("general audience");
    let tone = request.tone.as_deref().unwrap_or("professional");

    let prompt = match request.content_type.as_str() {
        "blog_post" => format!(
            "Write a comprehensive blog post about '{}' for {}. Use a {} tone.
            Target approximately {} words. Include:
            - Engaging title
            - Introduction
            - Key points with subheadings
            - Practical examples
            - Conclusion with actionable insights

            Format: Return only the title on the first line, followed by a blank line, then the content.",
            request.topic, audience, tone, target_words
        ),
        "social_media_post" => format!(
            "Create an engaging social media post about '{}' for {}. Use a {} tone.
            Target approximately {} words. Include:
            - Hook to grab attention
            - Key value or insight
            - Call to action
            - Relevant hashtags

            Format: Return only the title on the first line, followed by a blank line, then the content.",
            request.topic, audience, tone, target_words
        ),
        "email_newsletter" => format!(
            "Write an email newsletter section about '{}' for {}. Use a {} tone.
            Target approximately {} words. Include:
            - Compelling subject line as title
            - Personal greeting
            - Main content with clear value
            - Call to action

            Format: Return only the title on the first line, followed by a blank line, then the content.",
            request.topic, audience, tone, target_words
        ),
        _ => format!(
            "Create content about '{}' for {}. Use a {} tone.
            Target approximately {} words. Provide valuable, actionable information.

            Format: Return only the title on the first line, followed by a blank line, then the content.",
            request.topic, audience, tone, target_words
        ),
    };

    let max_tokens = std::cmp::min(target_words * 2, 2048); // Rough estimate for tokens
    let generated_text = gemini_client
        .generate_content(&prompt, max_tokens as u32)
        .await?;

    // Parse title and content from the response
    let lines: Vec<&str> = generated_text.lines().collect();
    if lines.len() >= 3 {
        let title = lines[0].trim().to_string();
        let content = lines[2..].join("\n").trim().to_string();
        Ok((title, content))
    } else {
        // Fallback parsing if format is not as expected
        let title = format!("Guide to {}", request.topic);
        Ok((title, generated_text))
    }
}

fn generate_fallback_content(request: &ContentRequest) -> (String, String) {
    match request.content_type.as_str() {
        "blog_post" => generate_fallback_blog_post(request),
        "social_media_post" => generate_fallback_social_media_post(request),
        "email_newsletter" => generate_fallback_email_newsletter(request),
        _ => generate_fallback_generic_content(request),
    }
}

fn generate_fallback_blog_post(request: &ContentRequest) -> (String, String) {
    let title = format!("The Complete Guide to {} in 2024", request.topic);
    let content = format!(
        "Understanding {}: A Comprehensive Guide

The world of {} is rapidly evolving, creating new opportunities and challenges for businesses and individuals alike. This comprehensive guide provides everything you need to know about {}.

## Key Benefits and Opportunities

• **Improved Efficiency**: Streamline processes and reduce manual work
• **Enhanced Quality**: Achieve better results with consistent standards
• **Cost Optimization**: Maximize ROI while minimizing resource waste
• **Competitive Advantage**: Stay ahead in an evolving marketplace

## Best Practices for Success

### Getting Started
Start with clear, measurable goals and a well-defined strategy. Understanding your specific needs and constraints is crucial for successful implementation.

### Implementation Strategy
• Invest in proper training and skill development
• Monitor progress regularly with key metrics
• Stay updated with latest trends and innovations
• Build flexible systems that can adapt to change

## Common Challenges and Solutions

**Challenge: Initial Complexity**
*Solution*: Break implementation into manageable phases and celebrate small wins.

**Challenge: Resource Requirements**
*Solution*: Plan carefully and consider phased approaches to spread costs over time.

**Challenge: Change Management**
*Solution*: Invest in communication and training to ensure team buy-in.

## Future Outlook

{} represents a significant opportunity for growth and innovation. Organizations that embrace these changes thoughtfully and strategically will be best positioned for long-term success.

## Conclusion

Success with {} requires a balanced approach combining strategic planning, practical implementation, and continuous learning. By following these guidelines and adapting them to your specific context, you can maximize the benefits while minimizing risks.",
        request.topic, request.topic, request.topic, request.topic, request.topic
    );
    (title, content)
}

fn generate_fallback_social_media_post(request: &ContentRequest) -> (String, String) {
    let title = format!("{} - Latest Insights", request.topic);
    let content = format!(
        "🚀 Exciting developments in {}!

Key benefits you can't ignore:
✨ Improved efficiency and productivity
📈 Better results and outcomes
🎯 Strategic competitive advantages
💡 Innovation opportunities

Ready to get started? Here's what successful organizations are doing:

🔥 Tip 1: Start with clear goals
📊 Tip 2: Measure what matters
🤝 Tip 3: Invest in your team
⚡ Tip 4: Stay agile and adaptable

What's your experience with {}? Share your thoughts below! 👇

#Innovation #Technology #{} #BusinessGrowth #DigitalTransformation #Success",
        request.topic,
        request.topic,
        request.topic.replace(" ", "")
    );
    (title, content)
}

fn generate_fallback_email_newsletter(request: &ContentRequest) -> (String, String) {
    let title = format!("Weekly Insights: {} Trends You Need to Know", request.topic);
    let content = format!(
        "Hi there! 👋

Hope you're having a great week! Today I wanted to share some exciting insights about {} that I think you'll find valuable.

## What's New in {}

The landscape is changing rapidly, and there are some fascinating developments that could impact your work:

• **Emerging Trends**: New approaches are creating opportunities for early adopters
• **Best Practices**: Industry leaders are sharing proven strategies for success
• **Tools & Resources**: Innovative solutions are making implementation easier than ever

## This Week's Key Insight

The most successful organizations aren't just adopting {} – they're thinking strategically about how it fits into their bigger picture. They're asking better questions and taking measured, thoughtful approaches.

## Quick Action Items

Here are three things you can do this week:
1. Assess your current situation and identify one area for improvement
2. Research one new tool or approach that could help
3. Start a conversation with your team about opportunities

## What's Next?

I'm curious to hear about your experiences with {}. What's working well for you? What challenges are you facing? Hit reply and let me know – I read every response!

Have a fantastic week ahead!

Best regards,
Your AI-CORE Team

P.S. If you found this helpful, feel free to forward it to a colleague who might benefit!",
        request.topic, request.topic, request.topic, request.topic
    );
    (title, content)
}

fn generate_fallback_generic_content(request: &ContentRequest) -> (String, String) {
    let title = format!("Essential Guide to {}", request.topic);
    let content = format!(
        "Welcome to {}!

This comprehensive guide covers the fundamental aspects of {} that every professional should understand.

## Key Points

• **Revolutionary Impact**: {} is transforming how we approach traditional challenges
• **Strategic Planning**: Success requires careful planning and thoughtful implementation
• **Measurable Benefits**: Organizations report significant improvements in efficiency and outcomes
• **Sustainable Growth**: Long-term success depends on building adaptable, resilient systems

## Getting Started

The journey begins with understanding your specific needs and constraints. Take time to assess your current situation and identify the most promising opportunities for improvement.

## Implementation Roadmap

1. **Assessment Phase**: Understand current state and define clear objectives
2. **Planning Phase**: Develop comprehensive strategy with realistic timelines
3. **Pilot Phase**: Start small and learn from initial implementations
4. **Scale Phase**: Expand successful approaches across the organization
5. **Optimization Phase**: Continuously improve based on results and feedback

## Success Factors

The most successful implementations share common characteristics:
- Clear leadership commitment and vision
- Adequate resource allocation and timeline planning
- Strong communication and change management
- Continuous learning and adaptation mindset
- Focus on measurable outcomes and value creation

## Conclusion

{} offers exciting opportunities for organizations willing to invest in thoughtful, strategic approaches. By following proven best practices and maintaining focus on value creation, you can achieve significant and sustainable improvements.

Remember: success is not about perfection – it's about progress, learning, and continuous improvement.",
        request.topic, request.topic, request.topic, request.topic
    );
    (title, content)
}

async fn get_content(
    State(_state): State<AppState>,
    Path(content_id): Path<Uuid>,
) -> impl IntoResponse {
    Json(ContentResponse {
        id: content_id,
        content_type: "blog_post".to_string(),
        title: "Sample Blog Post".to_string(),
        content: "This is a sample blog post content for demonstration purposes.".to_string(),
        word_count: 11,
        status: "completed".to_string(),
        created_at: Utc::now(),
        processing_time_ms: 1250,
        ai_model: "gemini-1.5-flash".to_string(),
    })
}

async fn get_capabilities(State(_state): State<AppState>) -> impl IntoResponse {
    Json(serde_json::json!({
        "service": "demo-content-mcp",
        "version": env!("CARGO_PKG_VERSION"),
        "ai_model": "gemini-1.5-flash",
        "supported_content_types": [
            "blog_post",
            "social_media_post",
            "email_newsletter"
        ],
        "max_word_count": 2000,
        "supports_images": false,
        "features": [
            "real_ai_generation",
            "fallback_content",
            "customizable_tone",
            "target_audience",
            "word_count_control"
        ]
    }))
}
